local MSG_CONTACT_POINT_RESPONSE = hash("contact_point_response")
local INPUT_LEFT = hash("left")
local INPUT_RIGHT = hash("right")
local INPUT_JUMP = hash("jump")
local INPUT_RESTART = hash("restart")
local GROUP_OBSTACLES = hash("obstacles")

local GRAVITY_PIXELS_PER_SECOND = vmath.vector3(0, -3000, 0)
local JUMP_TAKEOFF_SPEED = 1200
local WALK_SPEED = 500
local CLIPUP_PIXELS = 20

local function find(t, value)
	for i, v in ipairs(t) do
		if v == value then
			return i
		end
	end
end

local function create_marker(self, pos, time)
	local marker_id = factory.create("#marker_factory", pos)
	if #self.debug_markers > 5 then
		local a = table.remove(self.debug_markers, 1)
		msg.post(a, "disable")
	end

	local sprite_url = msg.url(nil, marker_id, "sprite")
	go.set(sprite_url, "tint", vmath.vector4(1, 0, 0, 1))

	table.insert(self.debug_markers, marker_id)

	timer.delay(time, false, function()
		if marker_id then
			local index = find(self.debug_markers, marker_id)
			if index then
				table.remove(self.debug_markers, index)
			end
			go.delete(marker_id)
		end
	end)
end

local function set_default_state(self)
	self.velocity = vmath.vector3()
	self.correction = vmath.vector3()
	self.faced_direction = 1
	self.ground_contact = true
	self.wall_contact = false

	go.set_position(vmath.vector3(62, 226, 0))
end

function init(self)
	self.debug_markers = {}

	set_default_state(self)

	msg.post(".", "acquire_input_focus")
end

local function update_animations(self)
	sprite.set_hflip("#sprite", self.faced_direction < 0)
end

function fixed_update(self, dt)
	update_animations(self)

	local offset = self.velocity * dt

	if not self.ground_contact then
		self.velocity = self.velocity + GRAVITY_PIXELS_PER_SECOND * dt
		-- Don't allow falling faster than gravity
		self.velocity.y = math.max(self.velocity.y, GRAVITY_PIXELS_PER_SECOND.y)
	end

	go.set_position(go.get_position() + offset)

	self.correction = vmath.vector3()
	self.wall_contact = false
	self.ground_contact = false
end

local function walk(self, direction)
	if direction ~= 0 then
		self.faced_direction = direction
	end
	if not self.wall_contact then
		self.velocity.x = WALK_SPEED * direction
	end
end

local function jump(self)
	if not self.ground_contact then
		return
	end
	self.ground_contact = false
	self.velocity.y = JUMP_TAKEOFF_SPEED
end

local function abort_jump(self)
	self.velocity.y = math.min(self.velocity.y, 0)
end

function on_input(self, action_id, action)
	if action_id == INPUT_LEFT then
		walk(self, -action.value)
	elseif action_id == INPUT_RIGHT then
		walk(self, action.value)
	elseif action_id == INPUT_JUMP then
		if action.pressed then
			jump(self)
		elseif action.released then
			abort_jump(self)
		end
	elseif action_id == INPUT_RESTART then
		set_default_state(self)
	end
end

---https://defold.com/manuals/physics/#resolving-kinematic-collisions
local function resolve_collision(self, message)
	local distance = message.distance
	local normal = message.normal

	-- Push the character out of any obstacles
	if distance > 0 then
		local proj = vmath.project(self.correction, normal * distance)
		if proj < 1 then
			local compensation = (distance - distance * proj) * normal
			go.set_position(go.get_position() + compensation)
			self.correction = self.correction + compensation
		end
	end

	-- -- Collision with wall
	-- if math.abs(normal.x) > 0.7 then
	-- 	-- We apparently can't get the collision box properties at runtime, so we need to
	-- 	-- calculate the wall height based off of something else
	-- 	local collision_box_position = go.get("#collisionobject#Box", "position")
	-- 	local collision_box_dimensions = go.get("#collisionobject#Box", "dimensions")

	-- 	local wall_height = go.get_position().y - go.get("#sprite", "size.y")/2 - message.position.y
	-- 	print(wall_height)
	-- 	if wall_height < CLIPUP_PIXELS then
	-- 		-- Instead of stopping movement completely, move the character on top of small ledges
	-- 		go.set_position(go.get_position() + vmath.vector3(0, wall_height, 0))
	-- 	else
	-- 		self.wall_contact = true
	-- 		self.velocity.x = 0
	-- 	end
	-- end

	-- collided with a wall
	-- stop horizontal movement
	if math.abs(normal.x) > 0.7 then
		self.wall_contact = true
		self.velocity.x = 0
	end
	-- collided with the ground
	-- stop vertical movement
	if normal.y > 0.7 then
		self.ground_contact = true
		self.velocity.y = 0
	end
	-- collided with the ceiling
	-- stop vertical movement
	if normal.y < -0.7 then
		self.velocity.y = 0
	end
end

function on_message(self, message_id, message, sender)
	if message_id == MSG_CONTACT_POINT_RESPONSE then
		if message.group == GROUP_OBSTACLES then
			resolve_collision(self, message)
			create_marker(self, message.position, 0.5)
		end
	end
end
