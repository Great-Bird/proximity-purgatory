local MSG_CONTACT_POINT_RESPONSE = hash("contact_point_response")
local INPUT_LEFT = hash("left")
local INPUT_RIGHT = hash("right")
local INPUT_JUMP = hash("jump")
local GROUP_OBSTACLES = hash("obstacles")

local GRAVITY_PIXELS_PER_SECOND = vmath.vector3(0, -3000, 0)
local JUMP_TAKEOFF_SPEED = 1200
local WALK_SPEED = 500

function init(self)
	self.velocity = vmath.vector3()
	self.correction = vmath.vector3()
	self.faced_direction = 1
	self.standing = false
	self.wall_contact = false

	msg.post(".", "acquire_input_focus")
end

local function update_animations(self)
	sprite.set_hflip("#sprite", self.faced_direction < 0)
end

function fixed_update(self, dt)
	update_animations(self)

	local offset = self.velocity * dt
	go.set_position(go.get_position() + offset)

	self.velocity = self.velocity + GRAVITY_PIXELS_PER_SECOND * dt
	-- Don't allow falling faster than gravity
	self.velocity.y = math.max(self.velocity.y, GRAVITY_PIXELS_PER_SECOND.y)

	self.correction = vmath.vector3()
	self.wall_contact = false
	self.standing = false
end

local function walk(self, direction)
	if direction ~= 0 then
		self.faced_direction = direction
	end
	if not self.wall_contact then
		self.velocity.x = WALK_SPEED * direction
	end
end

local function jump(self)
	if not self.standing then
		return
	end
	self.standing = false
	self.velocity.y = JUMP_TAKEOFF_SPEED
end

local function abort_jump(self)
	self.velocity.y = math.min(self.velocity.y, 0)
end

function on_input(self, action_id, action)
	if action_id == hash("left") then
		walk(self, -action.value)
	elseif action_id == INPUT_RIGHT then
		walk(self, action.value)
	elseif action_id == INPUT_JUMP then
		if action.pressed then
			jump(self)
		elseif action.released then
			abort_jump(self)
		end
	end
end

---Resolves collisions with objects.
---https://defold.com/manuals/physics/#resolving-kinematic-collisions
---@param self any
---@param distance vector3
---@param normal vector3
local function resolve_collision(self, distance, normal)
	if distance > 0 then
		local proj = vmath.project(self.correction, normal * distance)
		if proj < 1 then
			local compensation = (distance - distance * proj) * normal
			go.set_position(go.get_position() + compensation)
			self.correction = self.correction + compensation
		end
	end

	-- Collision with wall
	if math.abs(normal.x) > 0.7 then
		self.wall_contact = true
		self.velocity.x = 0
	end
	-- Collision with ground
	if normal.y > 0.7 then
		self.standing = true
		self.velocity.y = 0
	end
	-- Collision with ceiling
	if normal.y < -0.7 and self.velocity.y > 0 then
		self.velocity.y = 0
	end
end

function on_message(self, message_id, message, sender)
	if message_id == MSG_CONTACT_POINT_RESPONSE then
		if message.group == GROUP_OBSTACLES then
			resolve_collision(self, message.distance, message.normal)
		end
	end
end
